/* $Id: QueryListener.java 157021 2015-03-11 16:19:11Z nwinant $
 */
package com.cyc.query;

/*
 * #%L
 * File: QueryListener.java
 * Project: Query API Implementation
 * %%
 * Copyright (C) 2013 - 2015 Cycorp, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
import com.cyc.base.CycAccessManager;
import com.cyc.base.CycApiException;
import com.cyc.base.CycConnectionException;
import com.cyc.base.CycTimeOutException;
import com.cyc.base.cycobject.CycList;
import com.cyc.base.cycobject.CycVariable;
import com.cyc.base.inference.InferenceStatus;
import com.cyc.base.inference.InferenceSuspendReason;
import com.cyc.base.inference.InferenceWorker;
import com.cyc.base.inference.InferenceWorkerListener;
import com.cyc.kb.Variable;
import com.cyc.kb.client.KBObjectImpl;
import com.cyc.kb.client.VariableImpl;
import com.cyc.kb.exception.KBTypeException;
import com.cyc.query.Query.QueryWorker;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EventListener;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This interface is one that must be implemented by anyone wishing to listen in
 * on events generated by a Query.
 *
 * @see Query
 * @author tbrussea, zelal
 * @version $Id: QueryListener.java 157021 2015-03-11 16:19:11Z nwinant $
 */
public abstract class QueryListener implements EventListener {

  public QueryListener() {
  }

  /**
   * This method is called when Cyc has created an inference for the query. That
   * means work has begun to find answers.
   *
   * @param query
   */
  abstract public void notifyInferenceCreated(Query query);

  /**
   * This method is called when the inference status has changed.
   *
   * @param oldStatus
   * @param newStatus
   * @param suspendReason
   * @param query
   */
  abstract public void notifyInferenceStatusChanged(InferenceStatus oldStatus, InferenceStatus newStatus,
          InferenceSuspendReason suspendReason, Query query);

  /**
   * Called when new answers have been found.
   *
   * @param query
   * @param newAnswers
   */
  abstract public void notifyInferenceAnswersAvailable(Query query, List<QueryAnswer> newAnswers);

  /**
   * Called when the inference has been terminated.
   *
   * @param query
   * @param e
   */
  abstract public void notifyInferenceTerminated(Query query, Exception e);

  InferenceWorkerListener getInferenceListener() {
    return inferenceListener;
  }

  private final InferenceWorkerListener inferenceListener = new InferenceWorkerListener() {
    private int nextAnswerId = 0;

    @Override
    public void notifyInferenceCreated(InferenceWorker inferenceWorker) {
      final Query query = getQuery(inferenceWorker);
      QueryListener.this.notifyInferenceCreated(query);
    }

    @Override
    public void notifyInferenceStatusChanged(InferenceStatus oldStatus, InferenceStatus newStatus,
            InferenceSuspendReason suspendReason, InferenceWorker inferenceWorker) {
      final Query query = getQuery(inferenceWorker);
      QueryListener.this.notifyInferenceStatusChanged(oldStatus, newStatus, suspendReason,
              query);
    }

    @Override
    public void notifyInferenceAnswersAvailable(InferenceWorker inferenceWorker, List newAnswers) {
      final List<QueryAnswer> newQueryAnswers = new ArrayList<QueryAnswer>(newAnswers.size());
      final Query query = getQuery(inferenceWorker);
      try {
        for (final Object newAnswer : newAnswers) {
          newQueryAnswers.add(getQueryAnswerFromCycBindings(query, (CycList<CycList>) newAnswer));
        }
      } catch (Exception ex) {

      }
      QueryListener.this.notifyInferenceAnswersAvailable(query, newQueryAnswers);
    }

    private QueryAnswer getQueryAnswerFromCycBindings(final Query query, final CycList<CycList> cycBindings)
            throws CycConnectionException {
      final QueryAnswer qa = query.getAnswer(nextAnswerId++);
      final Map<Variable, Object> bindings = gatherBindings(cycBindings, qa);
      if (bindings == null) {
        return qa;
      } else {
        return new BindingsBackedQueryAnswer(bindings);
      }
    }

    /**
     * We prefer to use <code>qa</code> as long as its bindings match
     * <code>cycBindings</code>. If they don't match, we return a map of bindings
     * to use, but the resulting QueryAnswer won't know its ID.
     *
     * @param cycBindings
     * @param qa
     * @return
     */
    private Map<Variable, Object> gatherBindings(CycList<CycList> cycBindings,
            final QueryAnswer qa) {
      final Map<Variable, Object> bindings = new HashMap<Variable, Object>(cycBindings.size());
      boolean qaGood = true;
      for (final CycList cycBinding : cycBindings) {
        try {
          final VariableImpl var = new VariableImpl((CycVariable) cycBinding.get(0));
          final Object val = KBObjectImpl.checkAndCastObject(cycBinding.getDottedElement());
          if (!(val.equals(qa.getBinding(var)))) {
            System.err.println("For " + var + ", expected " + qa.getBinding(var) + ", got " + val);
            qaGood = false;
          }
          bindings.put(var, val);
        } catch (KBTypeException ex) {
          logger.error("Problem getting binding.", ex);
        } finally {
          return null;
        }
      }
      return (qaGood ? null : bindings);
    }
    private final Logger logger = LoggerFactory.getLogger(QueryListener.class.getName());

    @Override
    public void notifyInferenceTerminated(InferenceWorker inferenceWorker, Exception e) {
      QueryListener.this.notifyInferenceTerminated(getQuery(inferenceWorker), e);
    }
  };

  static private Query getQuery(InferenceWorker inferenceWorker) {
    return ((QueryWorker) inferenceWorker).getQuery();
  }

}
